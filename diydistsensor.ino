// DIY Distance Sensor(LEGO SPIKE prime)
// for Seeeduino XIAO/M5StickC
// by takuya matsubara

// Reference Data
// https://github.com/sonoisa/cheese/
// https://github.com/ahmedjouirou/legopup_arduino
// https://www.philohome.com/wedo2reverse/protocol.htm

#define DEBUG 1     // 1=ON / 0=OFF
#define M5STICKC 0  // 1=ON(M5StickC) / 0=OFF(seeeduino XIAO)

#if M5STICKC
  #include <M5StickC.h>
// M5StickC Extention port:SPIKE(WeDo2.0) connector
// GND  ---- (3)GND
// G26  ---> (6)Device to Hub
// G36  <--- (5)Hub to Device
  #define GPIOTX 26   // GPIO pin:TX
  #define GPIORX 36   // GPIO pin:RX
#else
// Seeeduino XIAO : SPIKE(WeDo2.0) connector 
//   GND   ---- (3)GND
// (D6)TX  ---> (6)Device to Hub
// (D7)RX  <--- (5)Hub to Device
  #define GPIOTX 6    // GPIO pin:TX
  #define GPIORX 7    // GPIO pin:RX
#endif

void sensor_init(void);
void sensor_control(void);
unsigned char checksum(unsigned char *ptr, int datasize);
void sensor_start(void);
void serial_senddata(unsigned char dat);
unsigned int serial_recvdata(void);
void baud2400_senddata(unsigned char dat);
unsigned int baud2400_recvdata(void);

unsigned char sensor_value;
unsigned int sensor_error;
bool sensor_connect;
unsigned char txbuf[10];

// message header
// 0x00+(00～3F)System message
// 0x40+(00～3F)Command message
// 0x80+(00～3F)Info message
// 0xC0+(00～3F)Data message

const unsigned char keyword[] = {
0x00,
0x40,0x3E,0x81,
0x49,0x07,0x07,0xB6,
0x52,0x00,0xC2,0x01,0x00,0x6E,
0x5F,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0xA0,
0xA7,0x00,0x66,0x6C,0x6F,0x61,0x74,0x5F,0x61,0x72,0x72,0x61,0x79,0x00,0x00,0x00,0x00,0x00,0x0E,
0x9F,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xEB,
0x9F,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xE8,
0x9F,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xE9,
0x87,0x04,0x00,0x7C,
0x8F,0x05,0x10,0x00,0x65,
0x97,0x80,0x04,0x03,0x02,0x01,0xEC,
0xA6,0x00,0x69,0x6E,0x74,0x33,0x32,0x5F,0x61,0x72,0x72,0x61,0x79,0x00,0x00,0x00,0x00,0x00,0x0D,
0x9E,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xEA,
0x9E,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xE9,
0x9E,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xE8,
0x86,0x04,0x00,0x7D,
0x8E,0x05,0x10,0x00,0x64,
0x96,0x80,0x04,0x02,0x03,0x00,0xEC,
0xA5,0x00,0x69,0x6E,0x74,0x31,0x36,0x5F,0x61,0x72,0x72,0x61,0x79,0x00,0x00,0x00,0x00,0x00,0x08,
0x9D,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xE9,
0x9D,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xEA,
0x9D,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xEB,
0x85,0x04,0x00,0x7E,
0x8D,0x05,0x10,0x00,0x67,
0x95,0x80,0x04,0x01,0x03,0x00,0xEC,
0xA4,0x00,0x69,0x6E,0x74,0x38,0x5F,0x61,0x72,0x72,0x61,0x79,0x00,0x00,0x00,0x00,0x00,0x00,0x36,
0x9C,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xE8,
0x9C,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xEB,
0x9C,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xEA,
0x84,0x04,0x00,0x7F,
0x8C,0x05,0x10,0x00,0x66,
0x94,0x80,0x04,0x00,0x03,0x00,0xEC,
0x9B,0x00,0x66,0x6C,0x6F,0x61,0x74,0x00,0x00,0x00,0x14,
0x9B,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xEF,
0x9B,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xEC,
0x9B,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xED,
0x83,0x04,0x00,0x78,
0x8B,0x05,0x10,0x00,0x61,
0x93,0x80,0x01,0x03,0x02,0x01,0xED,
0x9A,0x00,0x69,0x6E,0x74,0x33,0x32,0x00,0x00,0x00,0x17,
0x9A,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xEE,
0x9A,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xED,
0x9A,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xEC,
0x82,0x04,0x00,0x79,
0x8A,0x05,0x10,0x00,0x60,
0x92,0x80,0x01,0x02,0x03,0x00,0xED,
0x99,0x00,0x69,0x6E,0x74,0x31,0x36,0x00,0x00,0x00,0x12,
0x99,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xED,
0x99,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xEE,
0x99,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xEF,
0x81,0x04,0x00,0x7A,
0x89,0x05,0x10,0x00,0x63,
0x91,0x80,0x01,0x01,0x03,0x00,0xED,
0x90,0x00,0x69,0x6E,0x74,0x38,0x24,
0x98,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xEC,
0x98,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xEF,
0x98,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xEE,
0x80,0x04,0x00,0x7B,
0x88,0x05,0x10,0x00,0x62,
0x90,0x80,0x01,0x00,0x03,0x00,0xED,
0x04
};

// 1000000/2400bps = 416.666micro sec
#define BAUD2400TIME 416

//--------------
void debug_message(char *ptr)
{
#if DEBUG == 0
  return;
#endif
  Serial.println(ptr);
#if M5STICKC
  M5.Lcd.setCursor(0, 0);
  M5.Lcd.print(ptr);  // error
#endif
}

//--------------
unsigned char checksum(unsigned char *ptr, int datasize){
  unsigned char dat, i;
  dat = 0xFF;
  for(i=0; i < datasize; i++){
    dat ^= *ptr;
    ptr++;
  }
  return dat;
}

//--------------
// send 1Byte(Sensor to Hub)
void serial_senddata(unsigned char dat)
{
  Serial1.write(dat);
}

//--------------
// recv 1Byte(Hub to Sensor)
unsigned int serial_recvdata(void)
{
  #define RECVTIMEOUT 0x400000
  unsigned char dat;
  long limit;

  limit = 0;
  while(Serial1.available() <= 0){
    limit++;
    if(limit > RECVTIMEOUT)
      return(0xffff);
  }
  dat = Serial1.read();
  return((unsigned int)dat);
}

//--------------
// 2400bps send 1byte(Sensor to Hub)
void baud2400_senddata(unsigned char dat)
{
  unsigned char mask;

  digitalWrite(GPIOTX, LOW);
  delayMicroseconds(BAUD2400TIME);
  mask = 0x01;
  while(mask){
    if(mask & dat){
      digitalWrite(GPIOTX, HIGH);
    }else{
      digitalWrite(GPIOTX, LOW);
    }
    delayMicroseconds(BAUD2400TIME);
    mask <<= 1;
  }
  digitalWrite(GPIOTX, HIGH);
  delayMicroseconds(BAUD2400TIME);
}

//--------------
// 2400bps recv 1byte(Hub to Sensor)
unsigned int baud2400_recvdata(void)
{
  #define RECVTIMEOUT 0x2000000
  unsigned char mask,dat;
  long cnt;

  cnt = 0;
  while(digitalRead(GPIORX) == HIGH){
    cnt++;
    if(cnt > RECVTIMEOUT)
      return(0xffff);
  }
  delayMicroseconds(BAUD2400TIME * 3 / 2);
  mask = 0x01;  // LSB
  dat = 0;
  while(mask){
    if(digitalRead(GPIORX) == HIGH) dat |= mask;
    delayMicroseconds(BAUD2400TIME);
    mask <<= 1;
  }
  return((unsigned int)dat);
}

//--------------
void sensor_init(void)
{
  Serial.begin(115200); // debug
  sensor_error = 0;
  sensor_value = 9;  // dummy data
  sensor_connect = false;
  delay(50);
}

//--------------
void sensor_start(void)
{
  int i;
  unsigned int dat;
  unsigned int pulsecnt;

  pinMode(GPIOTX, OUTPUT);
  pinMode(GPIORX, INPUT);
  digitalWrite(GPIOTX, HIGH);

  debug_message("start");
  pulsecnt = 0;
  while(1){
    dat = baud2400_recvdata();
    if(dat == 0xF0){  // exist Large-Hub
      pulsecnt++;
      if(pulsecnt >= 40){
        break;
      }
    }
  }
  debug_message("detect");

  delayMicroseconds(BAUD2400TIME*10*3);
  baud2400_senddata(0xF0);
  digitalWrite(GPIOTX, LOW);
  delay(500);
  digitalWrite(GPIOTX, HIGH);
  for(i=0; i<sizeof(keyword); i++){
      baud2400_senddata(keyword[i]);
  }

  sensor_error = 0;
  while(1){
      dat = baud2400_recvdata();
      if (dat == 0x04){   // success
        sensor_connect = true;
        break;
      }
      if(dat == 0xFFFF){  // timeout
        debug_message("timeout");
        break;
      }
      sensor_error++;
      if (sensor_error >= 40){ // wrong data error
        debug_message("data err");
        break;
      }
  }
  if(sensor_connect == false){  // error
    delay(100);
    return;
  }
  debug_message("connect");
  // success
#if M5STICKC
  Serial1.begin(115200, SERIAL_8N1,GPIORX,GPIOTX);
#else
  Serial1.begin(115200);
#endif
  delay(5);
}

//--------------
void sensor_control(void)
{
  unsigned int dat;
  int recvcnt,mode,i;
  
  if(sensor_connect == false){
    sensor_start();   // connection to hub
    return;
  }
  dat = serial_recvdata();
  if(dat == 0x02) {
    sensor_value++;
    if (sensor_value > 9) sensor_value=1;
    sensor_error = 0;
  }else if(dat == 0x43){
    dat = serial_recvdata();  // mode
    dat = serial_recvdata();  // get checksum
  }else if(dat == 0x46){ //
    dat = serial_recvdata();  // 0x00
    dat = serial_recvdata();  // 0xB9
    dat = serial_recvdata();  // size and mode
    mode = dat & 0b111;
    recvcnt = 1 << ((dat >> 3)& 0b111);

    for (i=0; i<recvcnt; i++){
      dat = serial_recvdata();
    }
    dat = serial_recvdata();  // get checksum
  }else if(dat == 0x4C){
    dat = serial_recvdata();  // value L
    dat = serial_recvdata();  // value H
    dat = serial_recvdata();  // get checksum
  }else{
    dat = serial_recvdata();
    dat = serial_recvdata();
  }
  if(dat == 0xFFFF){  // timeout
      sensor_connect = false;
      Serial1.end();
      debug_message("exit");
      delay(1000);
      return;
  }

  txbuf[0] = 0xC0;              // header
  txbuf[1] = sensor_value;      // 
  txbuf[2] = checksum(txbuf,2); // checksum
  for(i=0; i<3; i++){
    serial_senddata(txbuf[i]);
  }
  delay(5);
}

//--------------
void setup() {
#if M5STICKC
  M5.begin();
  M5.Lcd.setRotation(3);  // 画面の向きを設定
  M5.Lcd.setTextSize(2);  // 文字サイズを設定
  M5.Lcd.setTextColor(WHITE, BLACK);  
#endif
  sensor_init();
}

//--------------
void loop() {
  sensor_control();
}
